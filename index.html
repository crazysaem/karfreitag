<!DOCTYPE html>
<html lang="en">
 
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Karfreitag Player</title>
  <link rel="icon"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext x='50' y='58' font-size='80' text-anchor='middle' dominant-baseline='central'%3E⛪%3C/text%3E%3C/svg%3E">
  <style>
    /* CSS Variables for theming */
    :root {
      /* Light theme colors */
      --bg-primary: #f0f0f0;
      --bg-secondary: #fff;
      --bg-tertiary: #f9f9f9;
      --text-primary: #333;
      --text-secondary: #555;
      --text-tertiary: #222;
      --border-color: #ddd;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --hover-bg: #f0f0f0;
      --active-bg: #e6f2ff;
      --input-border: #ccc;
      --scrollbar-bg: #f1f1f1;
      --scrollbar-thumb: #888;
      --scrollbar-thumb-hover: #555;
      --overlay-bg: rgba(0, 0, 0, 0.7);
      --login-box-bg: white;
      --login-shadow: rgba(0, 0, 0, 0.3);
    }

    /* Dark theme colors */
    [data-theme="dark"] {
      --bg-primary: #1a1a1a;
      --bg-secondary: #2a2a2a;
      --bg-tertiary: #333;
      --text-primary: #e0e0e0;
      --text-secondary: #b0b0b0;
      --text-tertiary: #f0f0f0;
      --border-color: #444;
      --shadow-color: rgba(0, 0, 0, 0.5);
      --hover-bg: #3a3a3a;
      --active-bg: #1a3a5a;
      --input-border: #555;
      --scrollbar-bg: #2a2a2a;
      --scrollbar-thumb: #555;
      --scrollbar-thumb-hover: #777;
      --overlay-bg: rgba(0, 0, 0, 0.85);
      --login-box-bg: #2a2a2a;
      --login-shadow: rgba(0, 0, 0, 0.6);
    }

    /* Smooth transition for theme changes */
    * {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    body {
      font-family: sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      overflow: hidden;
    }

    /* Theme Toggle Button */
    .theme-toggle {
      position: fixed;
      top: 15px;
      left: 15px;
      z-index: 10000;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px var(--shadow-color);
      font-size: 20px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .theme-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 3px 12px var(--shadow-color);
    }

    .theme-toggle:active {
      transform: scale(0.95);
    }

    /* Toast Notification Styles */
    #toastContainer {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .toast {
      background-color: #333;
      color: white;
      padding: 12px 18px;
      border-radius: 5px;
      margin-bottom: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transform: translateX(100%);
      transition: opacity 0.5s ease, transform 0.5s ease;
      font-size: 0.9em;
      min-width: 200px;
      max-width: 350px;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.error {
      background-color: #d9534f;
    }

    .toast.success {
      background-color: #5cb85c;
    }

    .toast.info {
      background-color: #5bc0de;
    }

    /* Login Screen Styles */
    .login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--overlay-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .login-box {
      background-color: var(--login-box-bg);
      padding: 30px 40px;
      border-radius: 8px;
      box-shadow: 0 5px 15px var(--login-shadow);
      text-align: center;
      width: 90%;
      max-width: 400px;
    }

    .login-box h2 {
      margin-top: 0;
      margin-bottom: 20px;
      color: var(--text-primary);
    }

    .login-box input[type="text"],
    .login-box input[type="password"] {
      width: calc(100% - 22px);
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid var(--input-border);
      border-radius: 4px;
      font-size: 1em;
      background-color: var(--bg-primary);
      color: var(--text-primary);
    }

    .login-box button {
      background-color: #5cb85c;
      color: white;
      padding: 12px 20px;
      border: none;
      border-radius: 4px;
      font-size: 1em;
      cursor: pointer;
      width: 100%;
      transition: background-color 0.2s;
    }

    .login-box button:hover {
      background-color: #4cae4c;
    }

    #playerWrapper {
      display: none;
      flex-direction: column;
      height: 100vh;
    }

    .container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .main-content {
      flex: 3;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 15px;
      background-color: var(--bg-secondary);
      box-shadow: 0 0 10px var(--shadow-color);
      position: relative;
      overflow: hidden;
    }

    .song-info {
      display: none;
      text-align: center;
      width: 95%;
      flex-shrink: 0;
      padding: 5px 0;
    }

    .song-info h2 {
      margin: 0;
      font-size: 1.7em;
      line-height: 1.2;
      color: var(--text-tertiary);
      word-break: break-word;
    }

    .song-info p {
      margin: 0;
      font-size: 0.95em;
      color: var(--text-secondary);
      word-break: break-word;
    }

    .cover-art-container {
      width: 100%;
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
    }

    .cover-art-container img {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 4px;
    }

    .song-list-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: var(--bg-tertiary);
      border-left: 1px solid var(--border-color);
      min-width: 300px;
    }

    .song-list-header {
      padding: 10px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .song-list-header h3 {
      margin: 0;
      font-size: 1.1em;
      color: var(--text-primary);
    }

    .header-buttons button {
      margin-left: 8px;
      padding: 3px 8px;
      font-size: 0.7em;
      cursor: pointer;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
    }

    .header-buttons button:hover {
      background-color: var(--hover-bg);
    }

    .song-list {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      margin: 0;
      list-style: none;
      background-color: var(--bg-tertiary);
    }

    /* Custom scrollbar for dark mode */
    .song-list::-webkit-scrollbar {
      width: 8px;
    }

    .song-list::-webkit-scrollbar-track {
      background: var(--scrollbar-bg);
    }

    .song-list::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 4px;
    }

    .song-list::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover);
    }

    .song-item {
      padding: 10px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      color: var(--text-primary);
    }

    .song-item:hover {
      background-color: var(--hover-bg);
    }

    .song-item.active {
      background-color: var(--active-bg);
      font-weight: bold;
    }

    .song-item img {
      width: 40px;
      height: 40px;
      margin-right: 10px;
      object-fit: cover;
      border-radius: 3px;
      background-color: var(--bg-primary);
    }

    .song-item-details {
      flex: 1;
      overflow: hidden;
    }

    .song-item-details .song-title {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.9em;
      color: var(--text-primary);
    }

    .song-item-details .song-artist-album {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.75em;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .song-artist-album {
      display: none;
    }

    .song-duration {
      font-size: 0.8em;
      color: var(--text-secondary);
      margin-left: 10px;
    }

    .controls-wrapper {
      background-color: var(--bg-secondary);
      padding: 10px 0;
      border-top: 1px solid var(--border-color);
      box-shadow: 0 -2px 8px var(--shadow-color);
      position: relative;
    }

    .progress-container {
      display: flex;
      align-items: center;
      padding: 0 15px;
      margin-bottom: 8px;
    }

    #currentTimeDisplay,
    #durationDisplay {
      font-size: 0.9em;
      min-width: 45px;
      text-align: center;
      color: var(--text-primary);
    }

    #timeSlider {
      flex: 1;
      margin: 0 10px;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: var(--border-color);
      outline: none;
      border-radius: 2px;
    }

    #timeSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: #5cb85c;
      cursor: pointer;
      border-radius: 50%;
    }

    #timeSlider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #5cb85c;
      cursor: pointer;
      border-radius: 50%;
    }

    .controls-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      padding: 0 15px;
    }

    .controls-container button {
      background: none;
      border: none;
      font-size: 1.8em;
      cursor: pointer;
      padding: 5px;
      transition: transform 0.1s;
      color: var(--text-primary);
    }

    .controls-container button:hover {
      transform: scale(1.1);
    }

    .controls-container button:active {
      transform: scale(0.9);
    }

    .random-toggle-container {
      display: flex;
      align-items: center;
      gap: 5px;
      color: var(--text-primary);
    }

    .random-toggle-container label {
      font-size: 0.9em;
      cursor: pointer;
    }

    .random-toggle-container input[type="checkbox"] {
      cursor: pointer;
    }

    .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid var(--border-color);
      border-top-color: #5cb85c;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .theme-toggle {
        width: 35px;
        height: 35px;
        font-size: 18px;
      }
      
      .container {
        flex-direction: column;
      }

      .song-list-wrapper {
        min-width: 0;
        max-height: 40vh;
      }

      .main-content {
        flex: 1;
      }

      body {
        overflow: auto;
      }
    }
  </style>
</head>

<body>
  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark/light mode">
    <span id="themeIcon">🌙</span>
  </button>

  <!-- Toast Container -->
  <div id="toastContainer"></div>

  <!-- Login Overlay -->
  <div class="login-overlay" id="loginOverlay">
    <div class="login-box">
      <h2>⛪ Karfreitag Player</h2>
      <input type="text" id="serverUrlInput" placeholder="Server URL (e.g., https://demo.navidrome.org)"
        autocomplete="url">
      <input type="text" id="usernameInput" placeholder="Username" autocomplete="username">
      <input type="password" id="passwordInput" placeholder="Password" autocomplete="current-password">
      <button id="loginButton">Login</button>
    </div>
  </div>

  <!-- Player Wrapper -->
  <div id="playerWrapper">
    <div class="container">
      <!-- Main Content (Album Art) -->
      <div class="main-content">
        <div class="song-info" id="songInfo">
          <h2 id="songTitle">No Song Playing</h2>
          <p id="songArtistAlbum">Select a song to play</p>
        </div>
        <div class="cover-art-container">
          <img id="coverArt" src="" alt="Album Cover" style="display: none;">
        </div>
      </div>

      <!-- Song List -->
      <div class="song-list-wrapper">
        <div class="song-list-header">
          <h3>Songs (<span id="songCount">0</span>)</h3>
          <div class="header-buttons">
            <button id="refreshButton" title="Refresh song list">🔄</button>
            <button id="clearCacheButton" title="Clear cache">🗑️</button>
          </div>
        </div>
        <div class="song-list" id="songList"></div>
      </div>
    </div>

    <!-- Controls -->
    <div class="controls-wrapper">
      <div class="progress-container">
        <span id="currentTimeDisplay">0:00</span>
        <input type="range" id="timeSlider" min="0" max="100" value="0" step="0.1">
        <span id="durationDisplay">0:00</span>
      </div>
      <div class="controls-container">
        <button id="prevButton" title="Previous">⏮️</button>
        <button id="playPauseButton" title="Play/Pause">▶️</button>
        <button id="nextButton" title="Next">⏭️</button>
        <div class="random-toggle-container">
          <input type="checkbox" id="randomToggle">
          <label for="randomToggle">Random</label>
        </div>
      </div>
    </div>

    <audio id="audioPlayer" preload="auto"></audio>
  </div>

  <script>
    // Theme Management
    const THEME_KEY = 'karfreitag-theme-preference';
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    
    // Check for saved theme preference or system preference
    function getThemePreference() {
      const savedTheme = localStorage.getItem(THEME_KEY);
      if (savedTheme) {
        return savedTheme;
      }
      // Check system preference
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    // Apply theme
    function applyTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      themeIcon.textContent = theme === 'dark' ? '☀️' : '🌙';
      localStorage.setItem(THEME_KEY, theme);
    }

    // Initialize theme
    const initialTheme = getThemePreference();
    applyTheme(initialTheme);

    // Theme toggle handler
    themeToggle.addEventListener('click', () => {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      applyTheme(newTheme);
    });

    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      // Only apply system theme if user hasn't manually set a preference
      if (!localStorage.getItem(THEME_KEY)) {
        applyTheme(e.matches ? 'dark' : 'light');
      }
    });

    // Original application code continues below...
    const API_VERSION = "1.13.0";
    const CLIENT_NAME = "KarfreitagPlayer";
    let SERVER_URL = "";
    let USERNAME = "";
    let PASSWORD = "";
    let isLoggedIn = false;
    let songs = [];
    let originalSongOrder = [];
    let currentSongIndex = -1;
    let isPlaying = false;
    let isSeeking = false;
    let isRandom = false;
    let playedSongIds = new Set();

    const LS_KEY_SERVER_URL = 'karfreitag_server_url';
    const LS_KEY_USERNAME = 'karfreitag_username';
    const LS_KEY_PASSWORD = 'karfreitag_password';
    const CACHE_KEY_PREFIX = 'karfreitag_songs_';

    const loginOverlay = document.getElementById('loginOverlay');
    const serverUrlInput = document.getElementById('serverUrlInput');
    const usernameInput = document.getElementById('usernameInput');
    const passwordInput = document.getElementById('passwordInput');
    const loginButton = document.getElementById('loginButton');

    const playerWrapper = document.getElementById('playerWrapper');
    const songListDiv = document.getElementById('songList');
    const songCount = document.getElementById('songCount');
    const refreshButton = document.getElementById('refreshButton');
    const clearCacheButton = document.getElementById('clearCacheButton');

    const songInfo = document.getElementById('songInfo');
    const songTitle = document.getElementById('songTitle');
    const songArtistAlbum = document.getElementById('songArtistAlbum');
    const coverArt = document.getElementById('coverArt');

    const audioPlayer = document.getElementById('audioPlayer');
    const playPauseButton = document.getElementById('playPauseButton');
    const prevButton = document.getElementById('prevButton');
    const nextButton = document.getElementById('nextButton');
    const timeSlider = document.getElementById('timeSlider');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const durationDisplay = document.getElementById('durationDisplay');
    const randomToggle = document.getElementById('randomToggle');

    const listSpinnerContainer = document.createElement('div');
    listSpinnerContainer.innerHTML = '<div class="spinner"></div>';

    let animationFrameId = null;
    let visualPlayerTime = 0;
    let lastKnownAudioTime = 0;
    let lastKnownAudioTimeUpdateTimestamp = performance.now();

    function showToast(message, type = 'info', duration = 3000) {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.getElementById('toastContainer').appendChild(toast);
      setTimeout(() => toast.classList.add('show'), 10);
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 500);
      }, duration);
    }

    function toHex(str) { return Array.from(str, c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(''); }

    async function subsonicRequest(endpoint, params = {}, serverUrl = null, username = null, password = null) {
      const url = new URL(`${(serverUrl || SERVER_URL).replace(/\/+$/, '')}/rest/${endpoint}`);
      url.searchParams.append('u', username || USERNAME);
      url.searchParams.append('p', `enc:${toHex(password || PASSWORD)}`);
      url.searchParams.append('v', API_VERSION);
      url.searchParams.append('c', CLIENT_NAME);
      url.searchParams.append('f', 'json');
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      const resp = await fetch(url);
      const data = await resp.json();
      if (data['subsonic-response']?.error) throw new Error(data['subsonic-response'].error.message || 'Unknown error');
      return data['subsonic-response'];
    }

    loginButton.onclick = async () => {
      const url = serverUrlInput.value.trim();
      const user = usernameInput.value.trim();
      const pass = passwordInput.value.trim();
      if (!url || !user || !pass) { showToast('Please fill in all fields.', 'error'); return; }
      try {
        await subsonicRequest('ping.view', {}, url, user, pass);
        SERVER_URL = url; USERNAME = user; PASSWORD = pass; isLoggedIn = true;
        playedSongIds.clear();
        showToast('Login successful!', 'success');
        loginOverlay.style.display = 'none'; playerWrapper.style.display = 'flex';
        await loadAndDisplaySongs();
        localStorage.setItem(LS_KEY_SERVER_URL, SERVER_URL);
        localStorage.setItem(LS_KEY_USERNAME, USERNAME);
        localStorage.setItem(LS_KEY_PASSWORD, PASSWORD);
      } catch (error) {
        showToast(`Login failed: ${error.message}`, 'error', 5000); isLoggedIn = false;
      }
    };

    refreshButton.onclick = async () => {
      if (!isLoggedIn) { showToast('Not logged in.', 'error'); return; }
      clearCachedSongs(); await loadAndDisplaySongs(); showToast('Song list refreshed!', 'success');
    };

    clearCacheButton.onclick = () => {
      clearCachedSongs(); showToast('Cache cleared!', 'info');
      if (isLoggedIn) loadAndDisplaySongs();
    };

    function getCacheKey() { return `${CACHE_KEY_PREFIX}${SERVER_URL}`; }
    function getCachedSongs() {
      const cached = localStorage.getItem(getCacheKey());
      return cached ? JSON.parse(cached) : null;
    }
    function setCachedSongs(songs) { localStorage.setItem(getCacheKey(), JSON.stringify(songs)); }
    function clearCachedSongs() { localStorage.removeItem(getCacheKey()); }

    async function fetchAllSongsFromServer() {
      let allSongs = [], offset = 0; const size = 500;
      try {
        while (true) {
          const data = await subsonicRequest('search3.view', { query: '', songCount: size, songOffset: offset });
          const fetchedSongs = data.searchResult3?.song || [];
          if (fetchedSongs.length === 0) break;
          allSongs = [...allSongs, ...fetchedSongs];
          offset += fetchedSongs.length;
          if (fetchedSongs.length < size) break;
        }
        console.log(`Fetched ${allSongs.length} songs`);
        if (allSongs.length > 0) setCachedSongs(allSongs);
        return allSongs;
      } catch (error) {
        console.error("Error fetching songs:", error); showToast(`Error fetching songs: ${error.message}`, 'error', 5000);
        return [];
      }
    }

    function generateUniqueId(song) {
      return song.id || `${song.title || 'unknown'}_${song.artist || 'unknown'}_${song.album || 'unknown'}_${song.duration || 0}`.replace(/\s+/g, '_').toLowerCase();
    }

    function displaySongs(songsArray) {
      songListDiv.innerHTML = '';
      const sortedSongs = [...songsArray].sort((a, b) => {
        const artistCompare = (a.artist || '').localeCompare(b.artist || '');
        if (artistCompare !== 0) return artistCompare;
        const albumCompare = (a.album || '').localeCompare(b.album || '');
        if (albumCompare !== 0) return albumCompare;
        return (a.title || '').localeCompare(b.title || '');
      });
      const processedSongs = sortedSongs.map(s => ({ ...s, uniqueId: generateUniqueId(s) }));
      songs = [...processedSongs]; originalSongOrder = [...processedSongs];
      songCount.textContent = songs.length;
      songs.forEach(song => {
        const item = document.createElement('div'); item.className = 'song-item';
        item.setAttribute('data-song-id', song.uniqueId);
        const img = document.createElement('img');
        img.src = getCoverArtUrl(song.coverArt || song.albumId, '80');
        img.alt = 'Cover'; img.loading = 'lazy';
        const details = document.createElement('div'); details.className = 'song-item-details';
        const title = document.createElement('div'); title.className = 'song-title';
        title.textContent = song.title || 'Unknown Title';
        const artistAlbum = document.createElement('div'); artistAlbum.className = 'song-artist-album';
        artistAlbum.textContent = `${song.artist || 'Unknown Artist'} - ${song.album || 'Unknown Album'}`;
        details.appendChild(title); details.appendChild(artistAlbum);
        const duration = document.createElement('span'); duration.className = 'song-duration';
        duration.textContent = formatTime(song.duration);
        item.appendChild(img); item.appendChild(details); item.appendChild(duration);
        item.onclick = () => playSongByUniqueId(song.uniqueId);
        songListDiv.appendChild(item);
      });
      console.log("Displayed songs:", songs.length);
    }

    function playSongByUniqueId(uniqueId) {
      const index = songs.findIndex(s => s.uniqueId === uniqueId);
      if (index === -1) { console.error("Song not found:", uniqueId); return; }
      currentSongIndex = index; const song = songs[index];
      if (!song.id) { console.error("Song missing ID:", song); showToast("Cannot play: Song missing ID", "error"); return; }
      const streamUrl = `${SERVER_URL.replace(/\/+$/, '')}/rest/stream.view?id=${song.id}&u=${USERNAME}&p=enc:${toHex(PASSWORD)}&v=${API_VERSION}&c=${CLIENT_NAME}&format=raw`;
      audioPlayer.src = streamUrl; audioPlayer.load();
      songTitle.textContent = song.title || 'Unknown Title';
      songArtistAlbum.textContent = `${song.artist || 'Unknown Artist'} - ${song.album || 'Unknown Album'}`;
      songInfo.style.display = 'none';
      if (song.coverArt || song.albumId) {
        coverArt.src = getCoverArtUrl(song.coverArt || song.albumId, '600');
        coverArt.style.display = 'block';
      } else { coverArt.style.display = 'none'; }
      updateActiveClass(); audioPlayer.play();
      if (isRandom) playedSongIds.add(song.uniqueId);
    }

    function togglePlayPause() {
      if (!audioPlayer.src) { if (songs.length > 0) { playSongByUniqueId(songs[0].uniqueId); } else { showToast("No songs to play.", "info"); } return; }
      if (isPlaying) { audioPlayer.pause(); } else { audioPlayer.play(); }
    }

    function smoothUpdateTimeSlider(timestamp) {
      if (!isSeeking && isPlaying && !audioPlayer.paused) {
        const elapsed = (timestamp - lastKnownAudioTimeUpdateTimestamp) / 1000;
        visualPlayerTime = Math.min(lastKnownAudioTime + elapsed, audioPlayer.duration || 0);
        timeSlider.value = visualPlayerTime; currentTimeDisplay.textContent = formatTime(visualPlayerTime);
        animationFrameId = requestAnimationFrame(smoothUpdateTimeSlider);
      }
    }

    audioPlayer.onloadedmetadata = () => {
      if (!isNaN(audioPlayer.duration)) { timeSlider.max = audioPlayer.duration; durationDisplay.textContent = formatTime(audioPlayer.duration); }
    };
    audioPlayer.onplay = () => {
      isPlaying = true; playPauseButton.textContent = '⏸️';
      lastKnownAudioTime = audioPlayer.currentTime; visualPlayerTime = lastKnownAudioTime;
      lastKnownAudioTimeUpdateTimestamp = performance.now();
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(smoothUpdateTimeSlider);
    };
    audioPlayer.onpause = () => {
      isPlaying = false; playPauseButton.textContent = '▶️';
      if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
      timeSlider.value = audioPlayer.currentTime; currentTimeDisplay.textContent = formatTime(audioPlayer.currentTime);
    };
    audioPlayer.ontimeupdate = () => {
      if (!isSeeking && isPlaying) {
        lastKnownAudioTime = audioPlayer.currentTime; lastKnownAudioTimeUpdateTimestamp = performance.now();
      }
    };
    audioPlayer.onended = () => {
      isPlaying = false; playPauseButton.textContent = '▶️';
      if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
      if (songs.length > 0) {
        if (isRandom) {
          let availableUnplayedSongs = songs.filter(s => !playedSongIds.has(s.uniqueId));
          if (availableUnplayedSongs.length === 0) {
            console.log("All songs played in random mode, resetting...");
            playedSongIds.clear(); availableUnplayedSongs = [...songs];
            if (availableUnplayedSongs.length > 1 && currentSongIndex !== -1) {
              const justFinishedId = songs[currentSongIndex].uniqueId;
              availableUnplayedSongs = availableUnplayedSongs.filter(s => s.uniqueId !== justFinishedId);
            }
          }
          if (availableUnplayedSongs.length > 0) {
            const randomSong = availableUnplayedSongs[Math.floor(Math.random() * availableUnplayedSongs.length)];
            playSongByUniqueId(randomSong.uniqueId);
          } else if (songs.length === 1) { playSongByUniqueId(songs[0].uniqueId); }
        } else {
          const nextIndex = (currentSongIndex + 1) % songs.length; playSongByUniqueId(songs[nextIndex].uniqueId);
        }
      }
    };
    audioPlayer.onerror = (e) => {
      console.error("Audio Player Error:", e, audioPlayer.error); let errorMsg = "Error during playback.";
      if (audioPlayer.error) {
        switch (audioPlayer.error.code) {
          case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Playback aborted.'; break;
          case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Network error during playback.'; break;
          case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Audio decoding error.'; break;
          case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Audio format not supported or source unavailable.'; break;
          default: errorMsg = `Unknown playback error (Code ${audioPlayer.error.code})`;
        }
      }
      showToast(errorMsg, 'error', 5000); isPlaying = false; playPauseButton.textContent = '▶️';
      if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
    };

    timeSlider.addEventListener('mousedown', () => { isSeeking = true; });
    timeSlider.addEventListener('input', () => {
      if (isSeeking && audioPlayer.src) currentTimeDisplay.textContent = formatTime(timeSlider.value);
    });
    timeSlider.addEventListener('change', () => {
      if (audioPlayer.src && !isNaN(audioPlayer.duration) && audioPlayer.seekable.length > 0) {
        const seekTime = parseFloat(timeSlider.value); audioPlayer.currentTime = seekTime;
        visualPlayerTime = seekTime; lastKnownAudioTime = seekTime;
        lastKnownAudioTimeUpdateTimestamp = performance.now();
        currentTimeDisplay.textContent = formatTime(seekTime);
      }
      isSeeking = false;
      if (isPlaying && !audioPlayer.paused) {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(smoothUpdateTimeSlider);
      } else if (audioPlayer.paused && audioPlayer.src) {
        currentTimeDisplay.textContent = formatTime(audioPlayer.currentTime);
        timeSlider.value = audioPlayer.currentTime;
        visualPlayerTime = audioPlayer.currentTime; lastKnownAudioTime = visualPlayerTime;
      }
    });

    function playNextPrev(isNext) {
      if (songs.length === 0) { showToast("No songs to play.", "info"); return; }
      let newIndex = -1;
      let potentialNextSong = null;

      if (isRandom) {
        let availableSongsToPlay = songs.filter(song => !playedSongIds.has(song.uniqueId));

        if (availableSongsToPlay.length === 0 && songs.length > 0) {
          showToast("All songs played in random mode! Resetting played list.", "info", 2500);
          playedSongIds.clear();
          availableSongsToPlay = [...songs];
          if (availableSongsToPlay.length > 1 && currentSongIndex !== -1 && songs[currentSongIndex]) {
            const currentPlayingUniqueId = songs[currentSongIndex].uniqueId;
            availableSongsToPlay = availableSongsToPlay.filter(s => s.uniqueId !== currentPlayingUniqueId);
            if (availableSongsToPlay.length === 0) {
              availableSongsToPlay = [songs.find(s => s.uniqueId === currentPlayingUniqueId)];
            }
          }
        }

        if (availableSongsToPlay.length > 0) {
          const randomIndexInAvailable = Math.floor(Math.random() * availableSongsToPlay.length);
          potentialNextSong = availableSongsToPlay[randomIndexInAvailable];
          newIndex = songs.findIndex(s => s.uniqueId === potentialNextSong.uniqueId);
        } else if (songs.length > 0) {
          console.warn("Random fallback: No unplayed songs after attempting reset, picking any random.");
          newIndex = Math.floor(Math.random() * songs.length);
          if (songs[newIndex]) { playedSongIds.clear(); }
        }
      } else {
        if (currentSongIndex === -1) {
          newIndex = isNext ? 0 : (songs.length > 0 ? songs.length - 1 : 0);
        } else {
          newIndex = (currentSongIndex + (isNext ? 1 : -1) + songs.length) % songs.length;
        }
      }

      if (newIndex !== -1 && songs[newIndex]) {
        playSongByUniqueId(songs[newIndex].uniqueId);
      } else if (songs.length > 0 && isRandom) {
        console.warn("Random selection resulted in bad index, picking first available or any random.");
        let fallbackSong = songs.find(s => !playedSongIds.has(s.uniqueId)) || songs[0];
        if (fallbackSong) playSongByUniqueId(fallbackSong.uniqueId);
      } else if (songs.length > 0 && !isRandom) {
        playSongByUniqueId(songs[0].uniqueId);
      } else {
        console.warn("Next/Prev could not determine a valid new index or no songs available.");
      }
    }

    function updateActiveClass() {
      document.querySelectorAll('.song-item.active').forEach(i => i.classList.remove('active'));
      if (currentSongIndex !== -1 && songs[currentSongIndex]) {
        const el = songListDiv.querySelector(`.song-item[data-song-id="${songs[currentSongIndex].uniqueId}"]`);
        if (el) { el.classList.add('active'); const itemR = el.getBoundingClientRect(), listR = songListDiv.getBoundingClientRect(); if (itemR.bottom < listR.top || itemR.top > listR.bottom) el.scrollIntoView({ behavior: 'auto', block: 'nearest' }); }
      }
    }
    function formatTime(s) { if (isNaN(s) || s == null) return "0:00"; const m = Math.floor(s / 60), sc = Math.floor(s % 60); return `${m}:${sc < 10 ? '0' : ''}${sc}`; }
    function getCoverArtUrl(id, size = '80') { return id ? `${SERVER_URL.replace(/\/+$/, '')}/rest/getCoverArt.view?id=${id}&size=${size}&u=${USERNAME}&p=enc:${toHex(PASSWORD)}&v=${API_VERSION}&c=${CLIENT_NAME}` : ''; }

    playPauseButton.onclick = togglePlayPause;
    nextButton.onclick = () => playNextPrev(true);
    prevButton.onclick = () => playNextPrev(false);

    randomToggle.onchange = () => {
      isRandom = randomToggle.checked;
      const currentPlayingSongUniqueId = (currentSongIndex !== -1 && songs[currentSongIndex]) ? songs[currentSongIndex].uniqueId : null;

      if (isRandom) {
        songs = [...originalSongOrder].sort(() => Math.random() - 0.5);
      } else {
        songs = [...originalSongOrder];
        playedSongIds.clear();
      }

      if (currentPlayingSongUniqueId) {
        currentSongIndex = songs.findIndex(s => s.uniqueId === currentPlayingSongUniqueId);
      } else {
        currentSongIndex = -1;
      }
      updateActiveClass();
    };

    async function loadAndDisplaySongs() {
      songListDiv.innerHTML = ''; songListDiv.prepend(listSpinnerContainer);
      playedSongIds.clear();
      const cached = getCachedSongs(); let songsToDisplay = cached;
      if (!cached) { console.log("Fetching songs for:", SERVER_URL); songsToDisplay = await fetchAllSongsFromServer(); }
      else { console.log("Using cached songs for:", SERVER_URL); }
      displaySongs(songsToDisplay || []);
    }

    async function initializeApp() {
      randomToggle.checked = false;
      const urlParams = new URLSearchParams(window.location.search);
      const urlServer = urlParams.get('server');
      const urlUser = urlParams.get('username');
      const urlPass = urlParams.get('password');
      let loginAttemptedViaUrl = false;

      if (urlServer && urlUser && urlPass) {
        loginAttemptedViaUrl = true;
        console.warn("Login attempt via URL parameters: Passwords in URLs are insecure and should only be used in trusted environments for non-sensitive accounts.");

        try {
          await subsonicRequest('ping.view', {}, urlServer, urlUser, urlPass);
          SERVER_URL = urlServer;
          USERNAME = urlUser;
          PASSWORD = urlPass;
          isLoggedIn = true;
          playedSongIds.clear();
          loginOverlay.style.display = 'none'; playerWrapper.style.display = 'flex';
          await loadAndDisplaySongs();
          localStorage.setItem(LS_KEY_SERVER_URL, SERVER_URL);
          localStorage.setItem(LS_KEY_USERNAME, USERNAME);
          localStorage.setItem(LS_KEY_PASSWORD, PASSWORD);
          return;
        } catch (error) {
          showToast(`Login via URL parameters failed: ${error.message || 'Unknown error'}. Falling back.`, 'error', 5000);
        } finally {
          if (window.history.replaceState) {
            const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
            window.history.replaceState({ path: cleanUrl }, '', cleanUrl);
          }
        }
      }

      const savedUrl = localStorage.getItem(LS_KEY_SERVER_URL);
      const savedUser = localStorage.getItem(LS_KEY_USERNAME);
      const savedPass = localStorage.getItem(LS_KEY_PASSWORD);

      if (savedUrl && savedUser && savedPass) {
        serverUrlInput.value = savedUrl; usernameInput.value = savedUser; passwordInput.value = savedPass;
        try {
          await subsonicRequest('ping.view', {}, savedUrl, savedUser, savedPass);
          SERVER_URL = savedUrl; USERNAME = savedUser; PASSWORD = savedPass; isLoggedIn = true;
          playedSongIds.clear();
          loginOverlay.style.display = 'none'; playerWrapper.style.display = 'flex';
          await loadAndDisplaySongs();
        } catch (error) {
          showToast(`Auto-login failed: ${error.message || 'Unknown error'}. Please log in.`, 'error', 5000);
          isLoggedIn = false; playerWrapper.style.display = 'none'; loginOverlay.style.display = 'flex';
        }
      } else {
        loginOverlay.style.display = 'flex'; playerWrapper.style.display = 'none';
        if (!loginAttemptedViaUrl) {
          if (!urlServer && !savedUrl) serverUrlInput.value = 'https://demo.navidrome.org/';
          if (!urlUser && !savedUser) usernameInput.value = 'demo';
          if (!urlPass && !savedPass) passwordInput.value = 'demo';
        } else {
          serverUrlInput.value = urlServer || '';
          usernameInput.value = urlUser || '';
          passwordInput.value = '';
        }
      }
    }
    initializeApp();
  </script>
</body>

</html>
